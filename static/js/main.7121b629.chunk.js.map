{"version":3,"sources":["pages/ColoredRoadMap/index.tsx","util/util.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["WrappedMap","mapContainer","React","createRef","start","stop","zoomLevels","Array","from","length","_","i","vecList","map","Vector","features","emptyStyle","Style","featuresLayerList","vec","VectorTile","source","style","feature","resolution","x","y","properties","getProperties","layer","laglng","geometry","flatCoordinates","sz","dx","dy","rgb","h","max","min","s","l","r","g","b","Math","round","hsl2rgb","atan2","PI","color","rs","gs","bs","toString","RGB2ColorCode","stroke","Stroke","width","curZoom","hashList","Set","waterStyle","fill","Fill","railStype","layers","VectorTileLayer","VectorTileSource","format","TopoJSON","layerName","url","attributions","maxZoom","key","join","has","kind","add","endIndices","undefined","ends_","forEach","num","routeFeature","Feature","LineString","origin","addFeature","featuresLayer","push","OLMap","target","this","current","view","OLView","center","fromLonLat","zoom","getView","setConstrainResolution","on","event","getZoom","index","setVisible","setState","ref","className","Component","ColoredRoadMap","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7121b629.chunk.js","sourcesContent":["import React from 'react';\n\nimport { default as OLMap } from 'ol/Map';\nimport { default as OLView } from 'ol/View';\nimport Style, { StyleFunction } from 'ol/style/Style';\nimport Stroke from 'ol/style/Stroke';\nimport Fill from 'ol/style/Fill';\nimport VectorTile from 'ol/layer/Vector';\nimport VectorTileLayer from 'ol/layer/VectorTile';\nimport VectorTileSource from 'ol/source/VectorTile';\nimport Vector from 'ol/source/Vector';\nimport TopoJSON from 'ol/format/TopoJSON';\nimport { fromLonLat } from 'ol/proj';\n\nimport 'ol/ol.css';\nimport Feature, { FeatureLike } from 'ol/Feature';\nimport BaseLayer from 'ol/layer/Base';\nimport LineString from 'ol/geom/LineString';\n\nimport \"./style.css\";\nimport { hsl2rgb, RGB2ColorCode, calcAtanDeg, range } from \"../../util/util\";\nimport { FeatureObjectProps } from \"../../interfaces/feature\";\n\nclass WrappedMap extends React.Component {\n  private mapContainer = React.createRef<HTMLDivElement>();\n\n  componentDidMount() {\n    const zoomLevels = range(0, 19);\n    const vecList = zoomLevels.map(() => new Vector({\n      features: []\n    }));\n    // 空の new Style() を返すと何も描写しない\n    const emptyStyle = new Style();\n    const featuresLayerList = vecList.map((vec) => new VectorTile({\n      source: vec,\n      style: (\n        feature: FeatureLike,\n        resolution: number\n      ) => {\n        // ここで色を決める\n        const properties = feature.getProperties() as FeatureObjectProps;\n        if (properties.layer === 'roads') {\n          const laglng = properties.geometry.flatCoordinates;\n          const sz = laglng.length;\n          const dx = laglng[sz - 2] - laglng[0];\n          const dy = laglng[sz - 1] - laglng[1];\n          const theta = calcAtanDeg(dx, dy);\n          const rgb = hsl2rgb(theta * 4);\n          const color = RGB2ColorCode(rgb.r, rgb.g, rgb.b);\n          return new Style({\n            stroke: new Stroke({\n              width: 1,\n              color: color\n            })\n          });\n        }\n        else {\n          return emptyStyle;\n        }\n      }\n    }));\n    let curZoom = 10;\n    const hashList = zoomLevels.map(() => new Set<string>());\n\n    const waterStyle = new Style({\n      fill: new Fill({\n        color: '#9db9e8',\n      }),\n    });\n    const railStype = new Style({\n      stroke: new Stroke({\n        color: '#000',\n        width: 2\n      }),\n    });\n\n    const styleFunction: StyleFunction = (\n      feature: FeatureLike,\n      resolution: number\n    ) => {\n      // RenderFeature から properties を取得\n      const properties = feature.getProperties() as FeatureObjectProps;\n      // properties に格納されているレイヤ名からスタイルを書き分ける\n      if (properties.layer === 'roads') {\n        const laglng = properties.geometry.flatCoordinates;\n        const sz = laglng.length / 2 - 1;\n        const key = laglng.join();\n        if (hashList[curZoom].has(key)) {\n          return emptyStyle;\n        }\n        // if (properties.bus_network !== undefined) { // バス路線を除外\n        //   return emptyStyle;\n        // }\n        if (properties.kind === 'aeroway' || properties.kind === 'ferry') {\n          return emptyStyle;\n        }\n        hashList[curZoom].add(key);\n        if (properties.kind === 'rail') {\n          return railStype;\n        }\n        if (properties.kind !== 'major_road'\n          && properties.kind !== 'minor_road'\n          && properties.kind !== 'highway'\n          && properties.kind !== 'path'\n          && properties.kind !== 'construction') {\n          return emptyStyle;\n        }\n\n        const endIndices = new Set<number>();\n        if (properties.geometry.ends_ !== undefined) {\n          properties.geometry.ends_.forEach((num) => {\n            endIndices.add(num - 1);\n          })\n        }\n        for (let i = 0; i < sz; ++i) {\n          if (endIndices.has(2 * i + 1)) continue;\n          const routeFeature = new Feature({\n            layer: 'roads',\n            geometry: new LineString([[laglng[2 * i], laglng[2 * i + 1]], [laglng[2 * i + 2], laglng[2 * i + 3]]]),\n            origin: properties\n          });\n          vecList[curZoom].addFeature(routeFeature);\n        }\n\n        return emptyStyle;\n      } else if (properties.layer === 'water') {\n        return waterStyle;\n      } else {\n        return emptyStyle;\n      }\n    };\n    const vectorTileLayer = new VectorTileLayer({\n      source: new VectorTileSource({\n        format: new TopoJSON({\n          layerName: 'layer',\n          layers: ['water', 'roads', 'buildings'],\n        }),\n        url: 'https://tile.nextzen.org/tilezen/vector/v1/all/{z}/{x}/{y}.topojson?api_key=z_YNM3cKSlyZmpn4pSlQlQ',\n        attributions: [\n          '&copy; OpenStreetMap,',\n          '<a href=\"https://github.com/iilj/colored-roads\">@iilj</a>'\n        ],\n        // minZoom: 10,\n        maxZoom: 19\n      }),\n      // minZoom: 10,\n      // maxZoom: 12,\n      style: styleFunction\n    });\n\n    // create feature layer and vector source\n    const layers = [vectorTileLayer] as BaseLayer[];\n    featuresLayerList.forEach((featuresLayer) => {\n      layers.push(featuresLayer);\n    });\n\n    // create map object with feature layer\n    const map = new OLMap({\n      target: this.mapContainer.current as HTMLDivElement,\n      view: new OLView({\n        center: fromLonLat([139.767125, 35.681236]),\n        zoom: curZoom,\n      }),\n      layers: layers,\n    });\n\n    map.getView().setConstrainResolution(true);\n    map.getView().on('change:resolution', (event) => {\n      const zoom = map.getView().getZoom();\n      if (zoom !== curZoom && zoom % 1 === 0) {\n        // vc.clear();\n        // vecList.forEach((vc, index) => {\n        //   if (index != zoom) vc.clear();\n        // });\n        featuresLayerList.forEach((featuresLayer, index) => {\n          featuresLayer.setVisible(index === zoom);\n        });\n        curZoom = zoom;\n      }\n    });\n\n    // save map and layer references to local state\n    this.setState({\n      map: map,\n      // featuresLayer: featuresLayer\n    });\n  }\n\n  render() {\n    return (\n      <>\n        <h1>道路を方角ごとに着色するやつ</h1>\n        <div ref={this.mapContainer} className='colored-road-map-container'></div>\n      </>\n    );\n  }\n};\n\nexport const ColoredRoadMap: React.FC = () => {\n  return (\n    <>\n      <WrappedMap />\n    </>\n  )\n};","export const hsl2rgb = (h: number, s: number = 100, l: number = 40) => {\n    let max, min;\n    const rgb = { 'r': 0, 'g': 0, 'b': 0 };\n\n    while (h >= 360) h -= 360;\n    while (h < 0) h += 360;\n\n    if (l <= 49) {\n        max = 2.55 * (l + l * (s / 100));\n        min = 2.55 * (l - l * (s / 100));\n    } else {\n        max = 2.55 * (l + (100 - l) * (s / 100));\n        min = 2.55 * (l - (100 - l) * (s / 100));\n    }\n\n    if (h < 60) {\n        rgb.r = max;\n        rgb.g = min + (max - min) * (h / 60);\n        rgb.b = min;\n    } else if (h >= 60 && h < 120) {\n        rgb.r = min + (max - min) * ((120 - h) / 60);\n        rgb.g = max;\n        rgb.b = min;\n    } else if (h >= 120 && h < 180) {\n        rgb.r = min;\n        rgb.g = max;\n        rgb.b = min + (max - min) * ((h - 120) / 60);\n    } else if (h >= 180 && h < 240) {\n        rgb.r = min;\n        rgb.g = min + (max - min) * ((240 - h) / 60);\n        rgb.b = max;\n    } else if (h >= 240 && h < 300) {\n        rgb.r = min + (max - min) * ((h - 240) / 60);\n        rgb.g = min;\n        rgb.b = max;\n    } else if (h >= 300 && h < 360) {\n        rgb.r = max;\n        rgb.g = min;\n        rgb.b = min + (max - min) * ((360 - h) / 60);\n    }\n\n    rgb.r = Math.round(rgb.r);\n    rgb.g = Math.round(rgb.g);\n    rgb.b = Math.round(rgb.b);\n    return rgb;\n};\n\nexport const RGB2ColorCode = (r: number, g: number, b: number) => {\n    let rs, gs, bs;\n    rs = r.toString(16);\n    if (rs.length === 1) rs = \"0\" + r;\n\n    gs = g.toString(16);\n    if (gs.length === 1) gs = \"0\" + g;\n\n    bs = b.toString(16);\n    if (bs.length === 1) bs = \"0\" + b;\n\n    return '#' + rs + gs + bs;\n}\n\nexport const calcAtanDeg = (x: number, y: number) => {\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\nexport const range = (start: number, stop: number) => Array.from({ length: (stop - start) + 1 }, (_, i) => start + i);","import React from 'react';\n// import logo from './logo.svg';\n// import './App.css';\nimport { ColoredRoadMap } from \"./pages/ColoredRoadMap\";\n\nfunction App() {\n  return (\n    <ColoredRoadMap />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}